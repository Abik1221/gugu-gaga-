{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/mesob/gugu-gaga-/front_end/lib/offline/queue.ts"],"sourcesContent":["import { openDB, type DBSchema, type IDBPDatabase } from \"idb\";\r\n\r\nconst DB_NAME = \"zemen-offline\";\r\nconst STORE_NAME = \"pending_requests\";\r\n\r\ninterface OfflineDbSchema extends DBSchema {\r\n  [STORE_NAME]: {\r\n    key: string;\r\n    value: OfflineRequestRecord;\r\n    indexes: { \"by-createdAt\": number };\r\n  };\r\n}\r\n\r\nexport async function queueRequest(\r\n  path: string,\r\n  init: RequestInit = {},\r\n  options: QueueRequestOptions = {}\r\n): Promise<OfflineRequestRecord> {\r\n  const headersArray = init.headers\r\n    ? Array.from(new Headers(init.headers).entries())\r\n    : undefined;\r\n  const body = typeof init.body === \"string\" ? init.body : null;\r\n\r\n  return addOfflineRequest({\r\n    path,\r\n    method: (init.method || \"GET\").toUpperCase(),\r\n    body,\r\n    headers: headersArray ?? null,\r\n    requiresAuth: options.requiresAuth ?? false,\r\n    tenantId: options.tenantId ?? null,\r\n    description: options.description ?? null,\r\n  });\r\n}\r\n\r\nexport type OfflineRequestRecord = {\r\n  id: string;\r\n  path: string;\r\n  method: string;\r\n  body?: string | null;\r\n  requiresAuth: boolean;\r\n  tenantId?: string | null;\r\n  headers?: [string, string][] | null;\r\n  createdAt: number;\r\n  attempts: number;\r\n  lastError?: string | null;\r\n  description?: string | null;\r\n};\r\n\r\nexport type OfflineQueueSummary = {\r\n  pending: number;\r\n};\r\n\r\nexport type QueueRequestOptions = {\r\n  tenantId?: string | null;\r\n  requiresAuth?: boolean;\r\n  description?: string | null;\r\n};\r\n\r\nlet dbPromise: Promise<IDBPDatabase<OfflineDbSchema>> | null = null;\r\n\r\nasync function getDb(): Promise<IDBPDatabase<OfflineDbSchema>> {\r\n  if (typeof window === \"undefined\" || !(\"indexedDB\" in window)) {\r\n    throw new Error(\"IndexedDB is not available in this environment\");\r\n  }\r\n\r\n  if (!dbPromise) {\r\n    dbPromise = openDB<OfflineDbSchema>(DB_NAME, 1, {\r\n      upgrade(db) {\r\n        if (!db.objectStoreNames.contains(STORE_NAME)) {\r\n          const store = db.createObjectStore(STORE_NAME, { keyPath: \"id\" });\r\n          store.createIndex(\"by-createdAt\", \"createdAt\");\r\n        }\r\n      },\r\n    });\r\n  }\r\n\r\n  return dbPromise;\r\n}\r\n\r\nfunction getEventTarget(): EventTarget | null {\r\n  if (typeof window === \"undefined\") return null;\r\n  if (!(\"CustomEvent\" in window)) return null;\r\n  return queueEventTarget;\r\n}\r\n\r\nconst queueEventTarget: EventTarget | null =\r\n  typeof window !== \"undefined\" ? new EventTarget() : null;\r\n\r\nfunction safeRandomId() {\r\n  if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\r\n    return crypto.randomUUID();\r\n  }\r\n  return `${Date.now()}-${Math.random().toString(16).slice(2)}`;\r\n}\r\n\r\nasync function emitQueueChange(): Promise<void> {\r\n  const target = getEventTarget();\r\n  if (!target) return;\r\n  try {\r\n    const summary = await getOfflineQueueSummary();\r\n    target.dispatchEvent(\r\n      new CustomEvent<OfflineQueueSummary>(\"change\", { detail: summary })\r\n    );\r\n  } catch {\r\n    target.dispatchEvent(\r\n      new CustomEvent<OfflineQueueSummary>(\"change\", { detail: { pending: 0 } })\r\n    );\r\n  }\r\n}\r\n\r\nexport async function addOfflineRequest(\r\n  data: Omit<\r\n    OfflineRequestRecord,\r\n    \"id\" | \"createdAt\" | \"attempts\" | \"lastError\"\r\n  >\r\n): Promise<OfflineRequestRecord> {\r\n  const record: OfflineRequestRecord = {\r\n    id: safeRandomId(),\r\n    createdAt: Date.now(),\r\n    attempts: 0,\r\n    lastError: null,\r\n    ...data,\r\n  };\r\n\r\n  try {\r\n    const db = await getDb();\r\n    await db.put(STORE_NAME, record);\r\n    await emitQueueChange();\r\n  } catch (error) {\r\n    console.error(\"Failed to add offline request\", error);\r\n  }\r\n\r\n  return record;\r\n}\r\n\r\nexport async function listOfflineRequests(): Promise<OfflineRequestRecord[]> {\r\n  try {\r\n    const db = await getDb();\r\n    const items = await db.getAllFromIndex(STORE_NAME, \"by-createdAt\");\r\n    return items.sort((a, b) => a.createdAt - b.createdAt);\r\n  } catch (error) {\r\n    console.error(\"Failed to list offline requests\", error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function removeOfflineRequest(id: string): Promise<void> {\r\n  try {\r\n    const db = await getDb();\r\n    await db.delete(STORE_NAME, id);\r\n    await emitQueueChange();\r\n  } catch (error) {\r\n    console.error(\"Failed to remove offline request\", error);\r\n  }\r\n}\r\n\r\nexport async function updateOfflineRequest(\r\n  record: OfflineRequestRecord\r\n): Promise<void> {\r\n  try {\r\n    const db = await getDb();\r\n    await db.put(STORE_NAME, record);\r\n    await emitQueueChange();\r\n  } catch (error) {\r\n    console.error(\"Failed to update offline request\", error);\r\n  }\r\n}\r\n\r\nexport async function clearOfflineRequests(): Promise<void> {\r\n  try {\r\n    const db = await getDb();\r\n    const tx = db.transaction(STORE_NAME, \"readwrite\");\r\n    await tx.store.clear();\r\n    await tx.done;\r\n    await emitQueueChange();\r\n  } catch (error) {\r\n    console.error(\"Failed to clear offline requests\", error);\r\n  }\r\n}\r\n\r\nexport async function getOfflineQueueSummary(): Promise<OfflineQueueSummary> {\r\n  try {\r\n    const db = await getDb();\r\n    const pending = await db.count(STORE_NAME);\r\n    return { pending };\r\n  } catch {\r\n    return { pending: 0 };\r\n  }\r\n}\r\n\r\nexport function subscribeToOfflineQueue(\r\n  callback: (summary: OfflineQueueSummary) => void\r\n): () => void {\r\n  const target = getEventTarget();\r\n  if (!target) {\r\n    callback({ pending: 0 });\r\n    return () => undefined;\r\n  }\r\n\r\n  const handler = (event: Event) => {\r\n    const detail = (event as CustomEvent<OfflineQueueSummary>).detail;\r\n    callback(detail);\r\n  };\r\n\r\n  target.addEventListener(\"change\", handler);\r\n  void getOfflineQueueSummary()\r\n    .then(callback)\r\n    .catch(() => callback({ pending: 0 }));\r\n\r\n  return () => {\r\n    target.removeEventListener(\"change\", handler);\r\n  };\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 185, "column": 0}, "map": {"version":3,"sources":["file:///D:/mesob/gugu-gaga-/front_end/node_modules/idb/build/index.js"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n"],"names":[],"mappings":";;;;;;;;;;AAAA,MAAM,gBAAgB,CAAC,QAAQ,eAAiB,aAAa,IAAI,CAAC,CAAC,IAAM,kBAAkB;AAE3F,IAAI;AACJ,IAAI;AACJ,qEAAqE;AACrE,SAAS;IACL,OAAQ,qBACJ,CAAC,oBAAoB;QACjB;QACA;QACA;QACA;QACA;KACH;AACT;AACA,qEAAqE;AACrE,SAAS;IACL,OAAQ,wBACJ,CAAC,uBAAuB;QACpB,UAAU,SAAS,CAAC,OAAO;QAC3B,UAAU,SAAS,CAAC,QAAQ;QAC5B,UAAU,SAAS,CAAC,kBAAkB;KACzC;AACT;AACA,MAAM,qBAAqB,IAAI;AAC/B,MAAM,iBAAiB,IAAI;AAC3B,MAAM,wBAAwB,IAAI;AAClC,SAAS,iBAAiB,OAAO;IAC7B,MAAM,UAAU,IAAI,QAAQ,CAAC,SAAS;QAClC,MAAM,WAAW;YACb,QAAQ,mBAAmB,CAAC,WAAW;YACvC,QAAQ,mBAAmB,CAAC,SAAS;QACzC;QACA,MAAM,UAAU;YACZ,QAAQ,KAAK,QAAQ,MAAM;YAC3B;QACJ;QACA,MAAM,QAAQ;YACV,OAAO,QAAQ,KAAK;YACpB;QACJ;QACA,QAAQ,gBAAgB,CAAC,WAAW;QACpC,QAAQ,gBAAgB,CAAC,SAAS;IACtC;IACA,yFAAyF;IACzF,+DAA+D;IAC/D,sBAAsB,GAAG,CAAC,SAAS;IACnC,OAAO;AACX;AACA,SAAS,+BAA+B,EAAE;IACtC,2EAA2E;IAC3E,IAAI,mBAAmB,GAAG,CAAC,KACvB;IACJ,MAAM,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC/B,MAAM,WAAW;YACb,GAAG,mBAAmB,CAAC,YAAY;YACnC,GAAG,mBAAmB,CAAC,SAAS;YAChC,GAAG,mBAAmB,CAAC,SAAS;QACpC;QACA,MAAM,WAAW;YACb;YACA;QACJ;QACA,MAAM,QAAQ;YACV,OAAO,GAAG,KAAK,IAAI,IAAI,aAAa,cAAc;YAClD;QACJ;QACA,GAAG,gBAAgB,CAAC,YAAY;QAChC,GAAG,gBAAgB,CAAC,SAAS;QAC7B,GAAG,gBAAgB,CAAC,SAAS;IACjC;IACA,gCAAgC;IAChC,mBAAmB,GAAG,CAAC,IAAI;AAC/B;AACA,IAAI,gBAAgB;IAChB,KAAI,MAAM,EAAE,IAAI,EAAE,QAAQ;QACtB,IAAI,kBAAkB,gBAAgB;YAClC,yCAAyC;YACzC,IAAI,SAAS,QACT,OAAO,mBAAmB,GAAG,CAAC;YAClC,0FAA0F;YAC1F,IAAI,SAAS,SAAS;gBAClB,OAAO,SAAS,gBAAgB,CAAC,EAAE,GAC7B,YACA,SAAS,WAAW,CAAC,SAAS,gBAAgB,CAAC,EAAE;YAC3D;QACJ;QACA,uCAAuC;QACvC,OAAO,KAAK,MAAM,CAAC,KAAK;IAC5B;IACA,KAAI,MAAM,EAAE,IAAI,EAAE,KAAK;QACnB,MAAM,CAAC,KAAK,GAAG;QACf,OAAO;IACX;IACA,KAAI,MAAM,EAAE,IAAI;QACZ,IAAI,kBAAkB,kBAClB,CAAC,SAAS,UAAU,SAAS,OAAO,GAAG;YACvC,OAAO;QACX;QACA,OAAO,QAAQ;IACnB;AACJ;AACA,SAAS,aAAa,QAAQ;IAC1B,gBAAgB,SAAS;AAC7B;AACA,SAAS,aAAa,IAAI;IACtB,mFAAmF;IACnF,qCAAqC;IACrC,8FAA8F;IAC9F,+FAA+F;IAC/F,+FAA+F;IAC/F,8FAA8F;IAC9F,uDAAuD;IACvD,IAAI,0BAA0B,QAAQ,CAAC,OAAO;QAC1C,OAAO;YAAU,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,OAAH,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;gBAAG,KAAH,QAAA,SAAA,CAAA,KAAO;;YACpB,8FAA8F;YAC9F,uBAAuB;YACvB,KAAK,KAAK,CAAC,OAAO,IAAI,GAAG;YACzB,OAAO,KAAK,IAAI,CAAC,OAAO;QAC5B;IACJ;IACA,OAAO;QAAU,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,OAAH,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;YAAG,KAAH,QAAA,SAAA,CAAA,KAAO;;QACpB,8FAA8F;QAC9F,uBAAuB;QACvB,OAAO,KAAK,KAAK,KAAK,CAAC,OAAO,IAAI,GAAG;IACzC;AACJ;AACA,SAAS,uBAAuB,KAAK;IACjC,IAAI,OAAO,UAAU,YACjB,OAAO,aAAa;IACxB,6EAA6E;IAC7E,uEAAuE;IACvE,IAAI,iBAAiB,gBACjB,+BAA+B;IACnC,IAAI,cAAc,OAAO,yBACrB,OAAO,IAAI,MAAM,OAAO;IAC5B,iEAAiE;IACjE,OAAO;AACX;AACA,SAAS,KAAK,KAAK;IACf,gGAAgG;IAChG,2FAA2F;IAC3F,IAAI,iBAAiB,YACjB,OAAO,iBAAiB;IAC5B,+EAA+E;IAC/E,wDAAwD;IACxD,IAAI,eAAe,GAAG,CAAC,QACnB,OAAO,eAAe,GAAG,CAAC;IAC9B,MAAM,WAAW,uBAAuB;IACxC,iCAAiC;IACjC,+DAA+D;IAC/D,IAAI,aAAa,OAAO;QACpB,eAAe,GAAG,CAAC,OAAO;QAC1B,sBAAsB,GAAG,CAAC,UAAU;IACxC;IACA,OAAO;AACX;AACA,MAAM,SAAS,CAAC,QAAU,sBAAsB,GAAG,CAAC;AAEpD;;;;;;CAMC,GACD,SAAS,OAAO,IAAI,EAAE,OAAO;QAAE,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,GAA1C,iEAA6C,CAAC;IACzE,MAAM,UAAU,UAAU,IAAI,CAAC,MAAM;IACrC,MAAM,cAAc,KAAK;IACzB,IAAI,SAAS;QACT,QAAQ,gBAAgB,CAAC,iBAAiB,CAAC;YACvC,QAAQ,KAAK,QAAQ,MAAM,GAAG,MAAM,UAAU,EAAE,MAAM,UAAU,EAAE,KAAK,QAAQ,WAAW,GAAG;QACjG;IACJ;IACA,IAAI,SAAS;QACT,QAAQ,gBAAgB,CAAC,WAAW,CAAC,QAAU,QAC/C,qFAAqF;YACrF,MAAM,UAAU,EAAE,MAAM,UAAU,EAAE;IACxC;IACA,YACK,IAAI,CAAC,CAAC;QACP,IAAI,YACA,GAAG,gBAAgB,CAAC,SAAS,IAAM;QACvC,IAAI,UAAU;YACV,GAAG,gBAAgB,CAAC,iBAAiB,CAAC,QAAU,SAAS,MAAM,UAAU,EAAE,MAAM,UAAU,EAAE;QACjG;IACJ,GACK,KAAK,CAAC,KAAQ;IACnB,OAAO;AACX;AACA;;;;CAIC,GACD,SAAS,SAAS,IAAI;QAAE,EAAE,OAAO,EAAE,GAAX,iEAAc,CAAC;IACnC,MAAM,UAAU,UAAU,cAAc,CAAC;IACzC,IAAI,SAAS;QACT,QAAQ,gBAAgB,CAAC,WAAW,CAAC,QAAU,QAC/C,qFAAqF;YACrF,MAAM,UAAU,EAAE;IACtB;IACA,OAAO,KAAK,SAAS,IAAI,CAAC,IAAM;AACpC;AAEA,MAAM,cAAc;IAAC;IAAO;IAAU;IAAU;IAAc;CAAQ;AACtE,MAAM,eAAe;IAAC;IAAO;IAAO;IAAU;CAAQ;AACtD,MAAM,gBAAgB,IAAI;AAC1B,SAAS,UAAU,MAAM,EAAE,IAAI;IAC3B,IAAI,CAAC,CAAC,kBAAkB,eACpB,CAAC,CAAC,QAAQ,MAAM,KAChB,OAAO,SAAS,QAAQ,GAAG;QAC3B;IACJ;IACA,IAAI,cAAc,GAAG,CAAC,OAClB,OAAO,cAAc,GAAG,CAAC;IAC7B,MAAM,iBAAiB,KAAK,OAAO,CAAC,cAAc;IAClD,MAAM,WAAW,SAAS;IAC1B,MAAM,UAAU,aAAa,QAAQ,CAAC;IACtC,IACA,4EAA4E;IAC5E,CAAC,CAAC,kBAAkB,CAAC,WAAW,WAAW,cAAc,EAAE,SAAS,KAChE,CAAC,CAAC,WAAW,YAAY,QAAQ,CAAC,eAAe,GAAG;QACpD;IACJ;IACA,MAAM,SAAS,eAAgB,SAAS;QAAE,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,OAAH,UAAA,OAAA,IAAA,OAAA,QAAA,OAAA,GAAA,OAAA,MAAA;YAAG,KAAH,OAAA,KAAA,SAAA,CAAA,KAAO;;QAC7C,wEAAwE;QACxE,MAAM,KAAK,IAAI,CAAC,WAAW,CAAC,WAAW,UAAU,cAAc;QAC/D,IAAI,SAAS,GAAG,KAAK;QACrB,IAAI,UACA,SAAS,OAAO,KAAK,CAAC,KAAK,KAAK;QACpC,6BAA6B;QAC7B,6DAA6D;QAC7D,uCAAuC;QACvC,8BAA8B;QAC9B,sDAAsD;QACtD,OAAO,CAAC,MAAM,QAAQ,GAAG,CAAC;YACtB,MAAM,CAAC,eAAe,IAAI;YAC1B,WAAW,GAAG,IAAI;SACrB,CAAC,CAAC,CAAC,EAAE;IACV;IACA,cAAc,GAAG,CAAC,MAAM;IACxB,OAAO;AACX;AACA,aAAa,CAAC,WAAa,CAAC;QACxB,GAAG,QAAQ;QACX,KAAK,CAAC,QAAQ,MAAM,WAAa,UAAU,QAAQ,SAAS,SAAS,GAAG,CAAC,QAAQ,MAAM;QACvF,KAAK,CAAC,QAAQ,OAAS,CAAC,CAAC,UAAU,QAAQ,SAAS,SAAS,GAAG,CAAC,QAAQ;IAC7E,CAAC;AAED,MAAM,qBAAqB;IAAC;IAAY;IAAsB;CAAU;AACxE,MAAM,YAAY,CAAC;AACnB,MAAM,iBAAiB,IAAI;AAC3B,MAAM,mCAAmC,IAAI;AAC7C,MAAM,sBAAsB;IACxB,KAAI,MAAM,EAAE,IAAI;QACZ,IAAI,CAAC,mBAAmB,QAAQ,CAAC,OAC7B,OAAO,MAAM,CAAC,KAAK;QACvB,IAAI,aAAa,SAAS,CAAC,KAAK;QAChC,IAAI,CAAC,YAAY;YACb,aAAa,SAAS,CAAC,KAAK,GAAG;gBAAU,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,OAAH,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;oBAAG,KAAH,QAAA,SAAA,CAAA,KAAO;;gBAC5C,eAAe,GAAG,CAAC,IAAI,EAAE,iCAAiC,GAAG,CAAC,IAAI,CAAC,CAAC,KAAK,IAAI;YACjF;QACJ;QACA,OAAO;IACX;AACJ;AACA,gBAAgB;IAAQ,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,OAAH,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;QAAG,KAAH,QAAA,SAAA,CAAA,KAAO;;IAC3B,8CAA8C;IAC9C,IAAI,SAAS,IAAI;IACjB,IAAI,CAAC,CAAC,kBAAkB,SAAS,GAAG;QAChC,SAAS,MAAM,OAAO,UAAU,IAAI;IACxC;IACA,IAAI,CAAC,QACD;IACJ,SAAS;IACT,MAAM,gBAAgB,IAAI,MAAM,QAAQ;IACxC,iCAAiC,GAAG,CAAC,eAAe;IACpD,4EAA4E;IAC5E,sBAAsB,GAAG,CAAC,eAAe,OAAO;IAChD,MAAO,OAAQ;QACX,MAAM;QACN,mEAAmE;QACnE,SAAS,MAAM,CAAC,eAAe,GAAG,CAAC,kBAAkB,OAAO,QAAQ,EAAE;QACtE,eAAe,MAAM,CAAC;IAC1B;AACJ;AACA,SAAS,eAAe,MAAM,EAAE,IAAI;IAChC,OAAQ,AAAC,SAAS,OAAO,aAAa,IAClC,cAAc,QAAQ;QAAC;QAAU;QAAgB;KAAU,KAC1D,SAAS,aAAa,cAAc,QAAQ;QAAC;QAAU;KAAe;AAC/E;AACA,aAAa,CAAC,WAAa,CAAC;QACxB,GAAG,QAAQ;QACX,KAAI,MAAM,EAAE,IAAI,EAAE,QAAQ;YACtB,IAAI,eAAe,QAAQ,OACvB,OAAO;YACX,OAAO,SAAS,GAAG,CAAC,QAAQ,MAAM;QACtC;QACA,KAAI,MAAM,EAAE,IAAI;YACZ,OAAO,eAAe,QAAQ,SAAS,SAAS,GAAG,CAAC,QAAQ;QAChE;IACJ,CAAC","ignoreList":[0],"debugId":null}}]
}